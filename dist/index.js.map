{"version":3,"file":"index.js","sources":["../src/token_type.js","../src/vcr.js","../src/token.js","../src/lexer.js","../src/presenter_json.js","../src/index.js"],"sourcesContent":["export const TokenType = Object.freeze({\n  EOF: -1,\n  DateTimeToken: \"DateTime\",\n\tFailToken: \"Fail\",\n\tLoadToken: \"Load\",\n\tMetaKeyToken: \"Meta Key\",\n\tMetaValueToken: \"Meta Value\",\n\tMovementToken: \"Movement\",\n\tNoteToken: \"Note\",\n\tRepToken: \"Rep\",\n\tSetToken: \"Set\",\n\tSupersetMovementToken: \"Superset Movement\"\n});\n","import {TokenType} from \"./token_type.js\";\n\nclass Tape {\n  constructor(chr, next) {\n    this.chr = chr;\n    this.next = next || null;\n  }\n}\n\n\nexport class VCR {\n  constructor(start) {\n    this.start = start || null\n  }\n\n  push(chr) {\n    let next = new Tape(chr);\n    \n    if (this.start == null) {\n      this.start = next;\n    } else {\n      next.next = this.start;\n      this.start = next;\n    }\n  }\n\n  pop() {\n    if (this.start == null) {\n      return TokenType.EOF;\n    }\n\n    let next = this.start;\n    this.start = next.next;\n\n    return next.chr;\n  }\n\n  clear() {\n    this.start = null;\n  }\n}\n","export class Token {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n\n  toString() {\n    return \"[\" + this.type + \"] \" + this.value;\n  }\n}\n","import {VCR} from \"./vcr\";\nimport {Token} from \"./token\";\nimport {TokenType} from \"./token_type\";\n\nexport class Lexer {\n\n  constructor(srcString, initState) {\n    this.done = false;\n    this.errorHandler = ((error) => { throw error; });\n    this.position = 0;\n    this.src = srcString;\n    this.start = 0;\n    this.state = initState || (() => {});\n    this.tokens = [];\n    this.vcr = new VCR();\n\n    this._output = {};\n  }\n\n  current() {\n    return this.src.slice(this.start, this.position);\n  }\n\n  emit(tokenType) {\n    let token = new Token(tokenType, this.current());\n\n    this.tokens.push(token)\n    this.start = this.position;\n    this.vcr.clear();\n  }\n\n  error(msg) {\n    this.errorHandler(msg);\n  }\n\n  ignore() {\n    this.vcr.clear();\n    this.start = this.position;\n  }\n\n  next() {\n    let chr = TokenType.EOF\n    let str = this.src.slice(this.position, this.src.length);\n\n    if (str.length != 0) {\n      chr = str[0];\n    }\n\n    this.position += 1;\n    this.vcr.push(chr);\n\n    return chr;\n  }\n\n  nextToken() {\n    return this.tokens.pop();\n  }\n\n  peek() {\n    let chr = this.next();\n    this.rewind();\n\n    return chr;\n  }\n\n  rewind() {\n    let chr = this.vcr.pop()\n\n    if (chr != TokenType.EOF) {\n      this.position -= 1;\n\n      if (this.position < this.start) {\n        this.position = this.start;\n      }\n    }\n  }\n\n  run(pCtx) {\n    while (this.state != null) {\n      this.state = this.state.call(pCtx, this);\n    }\n\n    this.done = true;\n  }\n\n  take(chrArray) {\n    let chr = this.next();\n\n    while(chrArray.includes(chr)) {\n      chr = this.next();\n    }\n\n    this.rewind();\n  }\n}\n","import {TokenType} from \"./token_type\";\n\nexport class PresenterJSON {\n  constructor(tokensArr) {\n    this.done = false;\n    // TODO: Validator class\n    this.errors = [];\n    this.tokens = tokensArr;\n    this.output = {\n      date: null,\n      metadata: {},\n      movements: [],\n      notes: []\n    }\n\n    this._process();\n  }\n\n  _process() {\n    let currentMetaKey = null;\n    let movementIndex = 0;\n\n    sessionLoop:\n      for (let i = 0; i < this.tokens.length; ++i) {\n        let token = this.tokens[i];\n\n        switch(token.type) {\n          case TokenType.DateTimeToken:\n            this.output.date = token.value;\n            break;\n          case TokenType.MetaKeyToken:\n            this.output.metadata[token.value] = null;\n            currentMetaKey = token.value;\n            break;\n          case TokenType.MetaValueToken:\n            this.output.metadata[currentMetaKey] = token.value;\n            break;\n          case TokenType.NoteToken:\n            this.output.notes.push(token.value);\n            break;\n          default:\n            movementIndex = i;\n            break sessionLoop;\n        }\n      }\n\n    if (movementIndex == this.tokens.length - 1) {\n      this.done = true;\n      return;\n    }\n\n    let buffer = [this.tokens[0]];\n    let inMovements = false;\n\n    for (let i = 1; i < this.tokens.length; ++i) {\n      let token = this.tokens[i];\n\n      if (token.type == TokenType.MovementToken || token.type == TokenType.SupersetMovementToken) {\n        this._marshalMovement(buffer);\n        buffer = [token];\n      } else {\n        buffer.push(token);\n      }\n    }\n\n    if (buffer.length > 0) {\n      this._marshalMovement(buffer);\n    }\n\n    this.done = true;\n    return;\n  }\n\n  _marshalMovement(movementTokens) {\n    let movement = {\n      metadata: {},\n      name: \"Unknown Movement\",\n      notes: [],\n      performances: [],\n      sequence: this.output.movements.length,\n      superset: false,\n      touched: false\n    };\n\n    let currentMetaKey = null;\n    let performanceIndex = 0;\n\n    movementLoop:\n      for (let i = 0; i < movementTokens.length; ++i) {\n        let token = movementTokens[i];\n\n        switch(token.type) {\n          case TokenType.SupersetMovementToken:\n            movement.superset = true;\n            movement.name = token.value;\n            break;\n\n          case TokenType.MovementToken:\n            movement.name = token.value;\n            break;\n\n          case TokenType.MetaKeyToken:\n            movement.metadata[token.value] = null;\n            currentMetaKey = token.value;\n            break;\n\n          case TokenType.MetaValueToken:\n            movement.metadata[currentMetaKey] = token.value;\n            break;\n\n          case TokenType.NoteToken:\n            movement.notes.push(token.value);\n            break;\n\n          default:\n            performanceIndex = i;\n            break movementLoop;\n        }\n        movement.touched = true;\n      }\n\n    if (movement.touched) {\n      delete movement.touched;\n      movement.performances = this._marshalPerformance(movementTokens.slice(performanceIndex));\n      this.output.movements.push(movement);\n    }\n  }\n\n  _marshalPerformance(performanceTokens) {\n    let performances = [];\n    let newPerformance = () => {\n      return {\n        fails: 0,\n        load: 0,\n        metadata: {},\n        reps: 0,\n        notes: [],\n        sets: 1,\n        touched: false,\n      }\n    };\n\n    let currentMetaKey = null;\n    let inLoad = false;\n    let performance = newPerformance();\n\n    let pushPerformance = (p) => {\n      delete performance.touched;\n      performance.sequence = performances.length;\n      performances.push(performance);\n      performance = newPerformance();\n    }\n\n    for (let i = 0; i < performanceTokens.length; ++i) {\n      let token = performanceTokens[i];\n\n      if (token.type == TokenType.LoadToken) {\n        if (performance.touched) {\n          if (performance.reps == 0 && performance.fails == 0) {\n            performance.reps = 1;\n          }\n\n          if (performance.load != 0) {\n            pushPerformance(performance);\n          }\n        } \n\n        let maybeLoad = parseFloat(token.value);\n        performance.load = (isNaN(maybeLoad)) ?\n          token.value :\n          maybeLoad;\n      } else {\n        switch(token.type) {\n          case TokenType.FailToken:\n            performance.fails = parseFloat(token.value);\n            break;\n\n          case TokenType.MetaKeyToken:\n            performance.metadata[token.value] = null;\n            currentMetaKey = token.value;\n            break;\n\n          case TokenType.MetaValueToken:\n            performance.metadata[currentMetaKey] = token.value;\n            break;\n\n          case TokenType.NoteToken:\n            performance.notes.push(token.value);\n            break;\n\n          case TokenType.RepToken:\n            performance.reps = parseFloat(token.value);\n            break;\n\n          case TokenType.SetToken:\n            performance.sets = parseInt(token.value, 10);\n            break;\n        }\n      }\n      performance.touched = true;\n    }\n\n    if (performance.reps == 0 && performance.fails == 0) {\n      performance.reps = 1;\n    }\n\n    if (performance.fails > 0 && performance.reps == 0) {\n      performance.reps = performance.fails;\n    }\n\n    pushPerformance(performance);\n\n    return performances;\n  }\n}\n","import {Lexer} from \"./lexer\";\nimport {PresenterJSON} from \"./presenter_json\";\nimport {TokenType} from \"./token_type\";\n\nclass Parser {\n\n  constructor(srcString) {\n    this.lexer = new Lexer(srcString, this.idleState);\n  }\n\n  parse(presenterType) {\n    this.lexer.run(this);\n\n    if (!presenterType) {\n      return this.lexer.tokens;\n    }\n\n    switch(presenterType) {\n      case \"json\":\n        let json = new PresenterJSON(this.lexer.tokens);\n\n        if (!json.done || json.errors.length > 0) {\n          // TODO: Wire up.\n          return { error: true }\n        }\n\n        return json.output;\n      default:\n        return this.lexer.tokens;\n    }\n  }\n\n  idleState(lexer) {\n    let chr = lexer.peek();\n\n    if (chr == TokenType.EOF) {\n      return null;\n    }\n\n    if (this._isWhitespace(chr) || this._isLineTerminator(chr)) {\n      lexer.next();\n      lexer.ignore();\n      return this.idleState(lexer);\n    }\n\n    switch(chr) {\n      case \"@\":\n        return this.dateTimeState(lexer);\n      case \"#\":\n        return this.metaKeyState(lexer);\n      case \"*\":\n        return this.noteState(lexer);\n      default:\n        return this.valueState(lexer);\n    }\n  }\n\n  dateTimeState(lexer) {\n    lexer.take([\"@\", \" \"]);\n    lexer.ignore();\n\n    let chr = lexer.next();\n\n    while(!this._isLineTerminator(chr)) {\n      chr = lexer.next();\n    }\n\n    lexer.rewind();\n    lexer.emit(TokenType.DateTimeToken);\n\n    return this.idleState;\n  }\n\n  metaKeyState(lexer) {\n    lexer.take([\"#\", \" \"]);\n    lexer.ignore();\n\n    let chr = lexer.next();\n\n    while(!this._isColonTerminator(chr)) {\n      chr = lexer.next();\n    }\n\n    lexer.rewind();\n    lexer.emit(TokenType.MetaKeyToken);\n\n    return this.metaValueState;\n  }\n\n  metaValueState(lexer) {\n    lexer.take([\":\", \" \"]);\n    lexer.ignore();\n\n    let chr = lexer.next();\n\n    while(!this._isLineTerminator(chr)) {\n      chr = lexer.next();\n    }\n\n    lexer.rewind();\n    lexer.emit(TokenType.MetaValueToken);\n\n    return this.idleState;\n  }\n\n  movementState(lexer) {\n    let superset = false;\n\n    let chr = lexer.next();\n\n    if (chr == \"+\") {\n      superset = true\n      lexer.take([\" \"]);\n      lexer.ignore();\n      chr = lexer.next();\n    }\n\n    if (chr == \"'\") {\n      lexer.ignore();\n      chr = lexer.next();\n    }\n\n    while(!this._isColonTerminator(chr)) {\n      chr = lexer.next();\n    }\n\n    lexer.rewind();\n\n    if (superset) {\n      lexer.emit(TokenType.SupersetMovementToken);\n    } else {\n      lexer.emit(TokenType.MovementToken);\n    }\n\n    lexer.take(\":\");\n    lexer.ignore();\n\n    return this.idleState;\n  }\n\n  noteState(lexer) {\n    lexer.take([\"*\", \" \"]);\n    lexer.ignore();\n\n    let chr = lexer.next();\n\n    while(!this._isLineTerminator(chr)) {\n      chr = lexer.next();\n    }\n\n    lexer.rewind();\n    lexer.emit(TokenType.NoteToken);\n\n    return this.idleState;\n  }\n\n  numberState(lexer) {\n    lexer.take([\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \".\"]);\n\n    switch(lexer.peek()) {\n      case \"f\": case \"F\":\n        lexer.emit(TokenType.FailToken);\n        break;\n      case \"r\": case \"R\":\n        lexer.emit(TokenType.RepToken);\n        break;\n      case \"s\": case \"S\":\n        lexer.emit(TokenType.SetToken);\n        break;\n      default:\n        lexer.emit(TokenType.LoadToken);\n    }\n\n    lexer.take([\"f\", \"F\", \"r\", \"R\", \"s\", \"S\"]);\n    lexer.ignore();\n\n    return this.idleState;\n  }\n\n  valueState(lexer) {\n    let chr = lexer.next();\n\n    if (chr == \"+\" || chr == \"'\") {\n      lexer.rewind();\n      return this.movementState(lexer);\n    }\n\n    if (isNaN(chr)) {\n      if (chr != \"b\" && chr != \"B\") {\n        lexer.rewind();\n        return this.movementState(lexer);\n      }\n\n      let p = lexer.peek();\n\n      if (p != \"w\" && p != \"W\") {\n        lexer.rewind();\n        return this.movementState(lexer);\n      }\n\n      while(!this._isWhitespace(chr)) {\n        chr = lexer.next();\n      }\n\n      lexer.rewind();\n      lexer.emit(TokenType.LoadToken);\n\n      return this.idleState;\n    }\n\n    return this.numberState(lexer);\n  }\n\n  _isColonTerminator(chr) {\n    return chr == TokenType.EOF || chr == \":\";\n  }\n\n  _isLineTerminator(chr) {\n    return chr == TokenType.EOF || chr == \";\" || chr == \"\\n\" || chr == \"\\r\";\n  }\n\n  _isWhitespace(chr) {\n    return /\\s/.test(chr);\n  }\n}\n\nexport default Parser;\n"],"names":["TokenType","Object","freeze","EOF","DateTimeToken","FailToken","LoadToken","MetaKeyToken","MetaValueToken","MovementToken","NoteToken","RepToken","SetToken","SupersetMovementToken","Tape","chr","next","this","VCR","start","push","pop","clear","Token","type","value","toString","Lexer","srcString","initState","done","errorHandler","error","position","src","state","tokens","vcr","_output","current","slice","emit","tokenType","token","msg","ignore","str","length","nextToken","peek","rewind","run","pCtx","call","take","chrArray","includes","PresenterJSON","tokensArr","errors","output","date","metadata","movements","notes","_process","currentMetaKey","movementIndex","sessionLoop","i","buffer","_marshalMovement","movementTokens","movement","name","performances","sequence","superset","touched","performanceIndex","movementLoop","_marshalPerformance","performanceTokens","performance","fails","load","reps","sets","pushPerformance","p","maybeLoad","parseFloat","isNaN","parseInt","lexer","idleState","parse","presenterType","json","_isWhitespace","_isLineTerminator","dateTimeState","metaKeyState","noteState","valueState","_isColonTerminator","metaValueState","movementState","numberState","test"],"mappings":"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"}